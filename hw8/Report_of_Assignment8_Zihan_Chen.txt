Report of Assignment8   Zihan Chen

This Assignment is mainly based on two parts, one is using the finite difference method to solve a given diffusion equation, the other is using Monte Carlo method for simulating the position of Z walkers on different time step. By assigning a proper value of D, We can see the position distribution of Z walkers is close to the solution of P from the PDE.

My work is mainly on providing the missing pieces for the 3 functions to make them work. I will explain the routine as following:
First of all, I deal with the finite difference solution to the diffusion equation. The main function is in diffring.cc. The procedure is:
1. Read the value of each parameters from "diffring.ini", and determine the number of timesteps.
2. Initialize the vector P for solution value, and matrix F for difference matrix. Then output P as the initial condition.
3. Use the function "fill_time_step_matrix()" to create the difference matrix F. In this function, I first get the size of F, then calculate the coefficient "lambda" ("alpha" in the lecture slides) from D, dt and dx. Then I fill the matrix with scheme of 2nd order center difference for space and forward Euler for time difference. Note that the boundary condition in this case is periodic, thus I set F[0][-1] = F[0][N-1] = lambda, F[N-1][N] = F[N-1][0] = lambda. 
4. Use function "cblas_dgemv()" to multiply the matrix F and vector P at every timestep. Note that we must create another vector P1 which is the copy of P but pass to the function cblas_dgemv as a parameter. This is because if we pass the vector P into the function twice, then the elements of P will be modified by the "feedbacks" from last product by one row of F. This part is modulized in the function "perform_time_step()". As the vector P gets updated, it is plotted out at every time step. 

Subsequently, I work on the Monte Carlo simulation stuff. The main function is in "walkring.cc". The procedure is:
1. Read the value of each parameter from "walkring.ini", in which provides the number of Z walkers. And determine the number of timesteps.
2. Initialize the array of Z walkers (the size of this array is Z). The element of this array is the position the each walker, as is described, each walker will jump at every timestep. The direction of the jumping is based on the probability p. Output the position of all the walkers as the initial condition.
3. In each time step, I need to simulate the motion of all Z walkers in the function "perform_time_step()". I take the following steps:
	(1) Creating a class "FairCoin" for generating the pseu random number by a seed (system time). In this class, I use "uniform_real_distribution<double>" to generate a PRN from the uniform probability distribution on (0.0, 1.0), use "default_random_engine" as the engine of seed, and a funtion "toss(p)" to return the result of motion: +1 (jump forward), -1 (jump backward) or 0 (stay), where p is the probability. The probability of +1, -1 and 0 are p, p and 1-2p, respectively. 
	(2) Do the toss for every walker at one timestep to decide their motions. Note that with the periodic boundary condition, I assume that if pos[i]<0, then assigning pos[i]=N-1, as jumping to the end point; if pos[i]>N-1, then assigning p[i] = 0, as jumping to the start point. With this scheme the periodic boundary condition is satisfied. 
4. Plot the position of all the Z walkers at each time step.
In this part, I encountered some trouble with the implementing of seed. At first I initialized the seed at each time step, then I found the output of the postion is so random. With the help of Ramses, I found that the seed should be initialized only once in one simulation(for all time steps), thus for each time step the PRN would remain the certain scheme from the seed. Then I got the right output at each time step with a large Z. The result is close to the result by the first method.

Then I analyzed how many walkers I need to get close to the equivalence. As is shown in the Assignment, with Z goes to infinite the equation is satisfied. Unfortunately, computer cannot calculate an infinite number. Thus I tried to find a minimum Z to make the two results as close as possible. There are many ways to compare the two results, and the most efficient way is to calculate the residule (L1 Norm) from the two solutions at each time step. But Ramses recommanded me to compare the results by observation (qualitative approach) since the residule calculation would take a lot effort and unnecessarily time. 
Thus, from my observation, I found when Z = 10000 the results are pretty closed. And when I increased Z to 50000 and 100000, the result became better and better.

Actually I prefer the first one, finite difference method. Because I am more familiar with it. If I could ensure the truncational error goes to zero when the discrete time and spatial size goes to zero while the difference scheme is stable, for a continuous initial condition problem the numerical solution is guaranteed to converged to the true solution. However, it seems that with Monte Carlo's method we cannot 100% sure with a limited number of simulation points. What's worse, as we increase the number of Z, it will take much more time to calculate, while finite difference method seems much faster. Take Z = 50000 for instance. The total time for the first method is  0.63s, while the Monte Carlo method is 49.30s, consuming much more time.